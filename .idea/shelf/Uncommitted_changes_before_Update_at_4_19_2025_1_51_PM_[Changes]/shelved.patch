Index: test.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom utils.data_loader import read_csv\r\nfrom optimisers.CCS import cyclic_coordinate_search\r\nfrom bots.example_bot import simple_bot\r\nfrom config import TRAINING_DATASET_PATH\r\n\r\ndata = read_csv(TRAINING_DATASET_PATH, start_date=\"2015-01-01\", end_date=\"2020-12-31\")\r\nparams = cyclic_coordinate_search(simple_bot, data)\r\nprint(params)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test.py b/test.py
--- a/test.py	(revision 2049fc086317ba896d2903a865917a74de6bfada)
+++ b/test.py	(date 1744982987115)
@@ -3,7 +3,17 @@
 from optimisers.CCS import cyclic_coordinate_search
 from bots.example_bot import simple_bot
 from config import TRAINING_DATASET_PATH
+from utils.plots import plot
 
+print("simple_bot")
+print(simple_bot)
 data = read_csv(TRAINING_DATASET_PATH, start_date="2015-01-01", end_date="2020-12-31")
 params = cyclic_coordinate_search(simple_bot, data)
 print(params)
+
+
+
+signals = simple_bot.signals_function(params, data)
+
+
+plot(data, signals)
\ No newline at end of file
Index: utils/plots.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import matplotlib.pyplot as plt\r\nimport numpy as np\r\n\r\ndef plot(data, signals):\r\n    # Plot 1: Closing prices with buy and sell signals\r\n    plt.figure(figsize=(12, 6))\r\n    plt.plot(data['close'].values, label='Closing Prices', color='blue', alpha=0.7)\r\n    buy_signals = np.where(signals == 1)[0]\r\n    plt.scatter(buy_signals, data['close'].values[buy_signals], label='Buy Signal', color='green', marker='^', alpha=1)\r\n    sell_signals = np.where(signals == -1)[0]\r\n    plt.scatter(sell_signals, data['close'].values[sell_signals], label='Sell Signal', color='red', marker='v', alpha=1)\r\n    plt.title('Closing Prices with Buy and Sell Signals')\r\n    plt.xlabel('Time (Index)')\r\n    plt.ylabel('Closing Price')\r\n    plt.legend()\r\n    plt.grid(alpha=0.3)\r\n    plt.savefig(\"signals_plot.png\")\r\n    print(\"Plot saved as 'signals_plot.png'\")\r\n\r\n    # Plot 2: Bar plot for buy and sell signals\r\n    plt.figure(figsize=(12, 6))\r\n    bar_colors = ['green' if signals[i] == 1 else 'red' for i in range(len(signals)) if signals[i] != 0]\r\n    bar_positions = [i for i in range(len(signals)) if signals[i] != 0]\r\n    bar_heights = [data['close'].values[i] for i in bar_positions]\r\n    plt.bar(bar_positions, bar_heights, color=bar_colors, alpha=0.7, width=5)\r\n    plt.title('Buy and Sell Signals (Bar Plot)')\r\n    plt.xlabel('Time (Index)')\r\n    plt.ylabel('Closing Price')\r\n    plt.grid(alpha=0.3)\r\n    plt.savefig(\"signals_bar_plot.png\")\r\n    print(\"Bar plot saved as 'signals_bar_plot.png'\")
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils/plots.py b/utils/plots.py
--- a/utils/plots.py	(revision 2049fc086317ba896d2903a865917a74de6bfada)
+++ b/utils/plots.py	(date 1744996749603)
@@ -1,6 +1,8 @@
 import matplotlib.pyplot as plt
 import numpy as np
-
+import matplotlib
+import matplotlib.pyplot as plt
+#matplotlib.use('TkAgg')
 def plot(data, signals):
     # Plot 1: Closing prices with buy and sell signals
     plt.figure(figsize=(12, 6))
@@ -28,4 +30,7 @@
     plt.ylabel('Closing Price')
     plt.grid(alpha=0.3)
     plt.savefig("signals_bar_plot.png")
-    print("Bar plot saved as 'signals_bar_plot.png'")
\ No newline at end of file
+    print("Bar plot saved as 'signals_bar_plot.png'")
+
+
+
Index: test_pso.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test_pso.py b/test_pso.py
new file mode 100644
--- /dev/null	(date 1744984202964)
+++ b/test_pso.py	(date 1744984202964)
@@ -0,0 +1,24 @@
+import numpy as np
+from utils.data_loader import read_csv
+from optimisers.CCS import cyclic_coordinate_search
+# from bots.pso_bot import simple_bot
+from config import TRAINING_DATASET_PATH
+from utils.plots import plot
+from bots.pso_bot import *
+
+print("simple_bot")
+
+data = read_csv(TRAINING_DATASET_PATH, start_date="2015-01-01", end_date="2020-12-31")
+params = optimize_bot_with_pso(data)
+signals = wma_rsi_signal_generator(params, data)
+
+
+print("Best hyperparameters:", params)
+
+#signals = simple_bot.signals_function(params, data)
+print("Buy count:", np.sum(signals == 1))
+print("Sell count:", np.sum(signals == -1))
+print("Hold count:", np.sum(signals == 0))
+
+
+plot(data, signals)
\ No newline at end of file
Index: bots/pso_bot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/bots/pso_bot.py b/bots/pso_bot.py
new file mode 100644
--- /dev/null	(date 1744993576145)
+++ b/bots/pso_bot.py	(date 1744993576145)
@@ -0,0 +1,170 @@
+import numpy as np
+import pandas as pd
+from pyswarm import pso
+
+# ÂÅáË®≠‰Ω†Â∑≤ÊúâÈÄô‰∫õÂáΩÊï∏ÔºàËá™Ë°åÂÆöÁæ©ÊàñÂºïÂÖ•Ôºâ
+from filters.wma import wma, sma_filter
+#from filters.rsi import rsi  # Ëá™Ë°åÊí∞ÂØ´ RSI ÂáΩÊï∏Êàñ‰ΩøÁî® ta Â∫´
+
+import numpy as np
+import pandas as pd
+
+# def rsi(prices, period=14):
+#     delta = np.diff(prices)
+#     delta = np.insert(delta, 0, 0)  # Ë£ú 0 ‰ΩøÈï∑Â∫¶Â∞çÈΩä
+#
+#     gain = np.where(delta > 0, delta, 0)
+#     loss = np.where(delta < 0, -delta, 0)
+#
+#     avg_gain = pd.Series(gain).rolling(window=period).mean()
+#     avg_loss = pd.Series(loss).rolling(window=period).mean()
+#
+#     rs = avg_gain / (avg_loss + 1e-10)  # Âä†‰∏ÄÂÄã epsilon Èò≤Ê≠¢Èô§‰ª• 0
+#     rsi = 100 - (100 / (1 + rs))
+#     return rsi.fillna(0).values
+
+# ==== BOT ÂÆöÁæ© ====
+class bot:
+    def __init__(self, signals_function, bounds):
+        self.signals_function = signals_function
+        self.bounds = bounds
+        self.params = None
+        self.data = None
+
+    def fitness(self, hyperparams, data, fee=0.03, initial_cash=1000):
+        signals = self.signals_function(hyperparams, data)
+        prices = data['close'].values
+        cash = initial_cash
+        btc = 0
+        for price, signal in zip(prices, signals):
+            if signal == 1 and cash > 0:
+                btc = (cash * (1 - fee)) / price
+                cash = 0
+            elif signal == -1 and btc > 0:
+                cash = btc * price * (1 - fee)
+                btc = 0
+        if btc > 0:
+            cash = btc * prices[-1] * (1 - fee)
+        return -cash  # Ê≥®ÊÑèÔºöPSO ÊòØÊúÄÂ∞èÂåñÂáΩÊï∏ÔºåÂõûÂÇ≥ -cash
+
+#==== Composite Filter (WMA + RSI Á≠ñÁï•) ====
+def wma_rsi_signal_generator(hyperparams, data):
+    prices = data['close'].values
+    p1, p2, rsi_period, rsi_buy_th, rsi_sell_th = map(int, hyperparams)
+
+    sma_fast = wma(prices, p1, sma_filter(p1))
+    sma_slow = wma(prices, p2, sma_filter(p2))
+    rsi_vals = rsi(prices, rsi_period)
+
+    signals = []
+    for i in range(len(prices)):
+        if i < max(p1, p2, rsi_period):
+            signals.append(0)
+            continue
+        bullish = sma_fast[i] > sma_slow[i] and rsi_vals[i] < rsi_buy_th
+        bearish = sma_fast[i] < sma_slow[i] and rsi_vals[i] > rsi_sell_th
+        if bullish:
+            signals.append(1)
+        elif bearish:
+            signals.append(-1)
+        else:
+            signals.append(0)
+    return np.array(signals)
+
+
+
+# def wma_rsi_signal_generator(hyperparams, data):
+#     prices = data['close'].values
+#     p1, p2, rsi_period, rsi_buy_th, rsi_sell_th = map(int, hyperparams)
+#
+#     sma_fast = wma(prices, p1, sma_filter(p1))
+#     sma_slow = wma(prices, p2, sma_filter(p2))
+#     rsi_vals = rsi(prices, rsi_period)
+#
+#     signals = []
+#     position = 0  # ‰øùÊåÅ position ÁãÄÊÖã
+#
+#     for i in range(len(prices)):
+#         if i < max(p1, p2, rsi_period):
+#             signals.append(0)
+#             continue
+#
+#         # üëá ‰ΩøÁî® OR Ê¢ù‰ª∂ËÆìË®äËôüÊõ¥ÂÆπÊòìÂá∫Áèæ
+#         buy_signal = (sma_fast[i] > sma_slow[i]) or (rsi_vals[i] < rsi_buy_th)
+#         sell_signal = (sma_fast[i] < sma_slow[i]) or (rsi_vals[i] > rsi_sell_th)
+#
+#         if buy_signal and position == 0:
+#             signals.append(1)
+#             position = 1
+#         elif sell_signal and position == 1:
+#             signals.append(-1)
+#             position = 0
+#         else:
+#             signals.append(0)
+#     return np.array(signals)
+
+
+
+
+
+
+
+
+# ==== ‰ΩøÁî®ÁØÑ‰æã ====
+def optimize_bot_with_pso(data):
+    composite_bot = bot(
+        wma_rsi_signal_generator,
+        # bounds=[  # (min, max) for each parameter
+        #     (5, 50),     # p1: WMA fast
+        #     (10, 100),   # p2: WMA slow
+        #     (7, 21),     # rsi_period
+        #     (20, 40),    # rsi_buy_threshold
+        #     (60, 80)     # rsi_sell_threshold
+        # ]
+
+        bounds=[
+            (5, 50),  # p1: WMA fast
+            (10, 100),  # p2: WMA slow
+            (7, 21),  # rsi_period
+            (30, 50),  # rsi_buy_threshold --> Âæû 20 Êì¥Â§ßÂà∞ 30
+            (50, 70)  # rsi_sell_threshold --> Âæû 60 Èôç‰ΩéÂà∞ 50
+        ]
+    )
+
+    def pso_fitness(x):
+        return composite_bot.fitness(x, data)
+
+    lb = [b[0] for b in composite_bot.bounds]
+    ub = [b[1] for b in composite_bot.bounds]
+
+    best_params, best_fitness = pso(pso_fitness, lb, ub, swarmsize=30, maxiter=50)
+
+    print(f"Best params: {best_params}")
+    print(f"Final cash: {-best_fitness:.2f}")
+    return best_params
+
+# ==== RSI Ë®àÁÆó ====
+def rsi(prices, period=14):
+    deltas = np.diff(prices)
+    seed = deltas[:period]
+    up = seed[seed >= 0].sum() / period
+    down = -seed[seed < 0].sum() / period
+    rs = up / down if down != 0 else 0
+    rsi_values = [100. - 100. / (1. + rs)]
+
+    for i in range(period, len(deltas)):
+        delta = deltas[i]
+        if delta >= 0:
+            up_val = delta
+            down_val = 0.
+        else:
+            up_val = 0.
+            down_val = -delta
+
+        up = (up * (period - 1) + up_val) / period
+        down = (down * (period - 1) + down_val) / period
+
+        rs = up / down if down != 0 else 0
+        rsi_values.append(100. - 100. / (1. + rs))
+    return np.array([0]*period + rsi_values)  # pad with zeros
+
